\subsection{ADD 3.0 (FDD)}\label{add3}
Attribut-driven-Design (ADD) bezeichnet ein Vorgehensmodell, bei dem iterativ ein Architekturdesign ausgearbeitet wird. ADD wird in Form von sogenannten Design Rounds durchgef\"uhrt. Eine Design-Round kann hierbei beispielsweise einem Sprint in SCRUM zugeordnet werden. Dies bedeutet in einem Projekt kann es mehrere Design-Rounds geben, mit denen die Software-Architektur verfeinert wird. \\

\subsubsection{Ziele der Methode}
ADD 3.0 soll einen konkreten und genauen Ansatz zum Entwurf einer Software-Architektur bieten. Der Fokus soll bei ADD 3.0 auf dem Design der Software-Architektur liegen, die nach \cite{Cer01} Grundvoraussetzung f\"ur agile Projekte ist.\\

Eine Eigenschaft, die bei ADD besonders hervorsticht ist, dass es innerhalb der Design-Rounds eine klare Folge von Anweisungen gibt, die auszuf\"uhren sind um die Software-Architektur zu entwickeln. Hierbei ist relevant zu erw\"ahnen, dass in ADD die Dokumentation und Analyse als wichtigste Elemente zur Entwicklung der Software-Architektur betrachtet werden. \\

\subsubsection{Funktionsweise der Methode}
Insgesamt umfasst ADD sieben Schritte die innerhalb einer Design-Round auszuf\"uhren sind. In Abbildung \ref{fig_add3} ist schematisch dargestellt wie eine Design-Round aufgebaut ist und welche Schritte auszuf\"uhren sind.\\

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.45]{add3.jpg} 
	\caption{Attribute Drive Design 3.0}\label{fig_add3}
\end{figure}

\paragraph{Randbedingungen}
Die Voraussetzung f\"ur die Nutzung von ADD 3.0 ist, dass bereits prim\"are funktionale Anforderungen und Szenarien erhoben sind. Dies bedeutet ADD 3.0 findet nicht direkt in der Anforderungsgewinnung Anwendung, sondern erst danach. \\

\paragraph{Eingabe}
ADD 3.0 wird von sogenannten Projekttreibern gesteuert. Projekttreiber sind die Eingaben, die vor einer Design-Round vorbereitet werden m\"ussen. Die vorzubereitenden Eingaben sind:\\

\begin{itemize}
\item \emph{Design Grund} \\
Es kann vielf\"altige Gr\"unde f\"ur den Entwurf einer Software Architektur geben. So kann es beispielsweise im Rahmen eines Projektes sein, oder als Vorbereitung auf kommende Projekte. Vor dem Beginn muss jedoch gekl\"art werden aus welchem Grund das Design ben\"otigt wird \cite{Cer01}.
\item \emph{Qualit\"atsattribute} \\
Unter Qualit\"atsattributen sind in dem Kontext von ADD 3.0 Eigenschaften eines Systems zu sehen, die entweder testbar oder messbar sind. Aus diesem Grund haben Qualit\"atsattribute den gr\"o\ss{}ten Einfluss auf die zu konzipierende Software-Architektur. Da die Qualit\"atsattribute besonders wichtig sind, hat ihre Erhebung eine besondere Bedeutung \cite{Cer01}.
\item \emph{Prim\"are Funktionalit\"at} \\
Unter der prim\"aren Funktionalit\"at ist zu verstehen, dass ein System die Aufgaben erf\"ullt die es erf\"ullen soll. W\"ahrend Qualit\"atsattribute vor allem das "wie" pr\"ufen, pr\"uft die prim\"are Funktionalit\"at das "was". Relevant ist hierbei, dass es in den Anforderungen vorkommen kann, dass die prim\"are Funktionalit\"at direkt mit Qualit\"atsattributen verkn\"upft ist \cite{Cer01}. 
\item \emph{Einschr\"ankungen} \\
Bei dem Entwurf einer Software Architektur gibt es immer Einschr\"ankungen, die ber\"ucksichtigt werden m\"ussen. obwohl es m\"oglich sein kann diese zu lockern sind sie dennoch konstante Faktoren die bei dem Design zu ber\"ucksichtigen sind \cite{Cer01}.
\item \emph{Architektonische Bedenken} \\
Es gibt einige architektonische Bedenken, die eine Rolle spielen k\"onnen:
\begin{itemize}
\item Unter \emph{grunds\"atzlichen Bedenken} sind Bedenken zu verstehen, die mit dem gesamten Design-Prozess in Bezug stehen. Diese k\"onnen beispielsweise die Zuteilung von Arbeitspaketen an Projektteams, Organisation des Programmcodes, Deployment oder Updates beinhalten \cite{Cer01}.
\item \emph{Spezielle Bedenken} formulieren Bedenken, die sich auf detailliertere System interne Aspekte beziehen. Diese k\"onnen beispielsweise Aspekte wie Exception Management, die Verwaltung von Abh\"angigkeiten, Logging oder Authentifikation beinhalten \cite{Cer01}.
\item Unter \emph{internen Anforderungen} sind Anforderungen zu verstehen, die h\"aufig nicht in den Anforderungsdokumenten genannt werden. Diese Anforderungen betreffen beispielsweise Entwicklung, Einsatz oder Wartung des Systems \cite{Cer01}.  
\item \emph{Probleme} sind in der Regel nicht bei der initialen Design-Round von Bedeutung. Nach der Ausf\"uhrung einer Design-Round kann es jedoch sein, dass mit dem aktuellen Software Design Risiken verbunden sind, die behoben werden m\"ussen. Diese sind in diesem Zusammenhang Probleme \cite{Cer01}.\\
\end{itemize}
\end{itemize}

\paragraph{Vorgehensmodell}
Grunds\"atzlich entspricht ein Durchlauf von ADD 3.0 in einem iterativen Entwicklungsvorgang einer Iteration. Wird das Wasserfall-Modell genutzt entspricht ein Durchlauf einer Menge von Architektur-Entwurf-Aktivit\"aten \cite{Cer01}.\\

Vor der erstmaligen Ausf\"uhrung von ADD 3.0 sollte \"uberpr\"uft werden ob alle notwendigen Eingaben vorhanden sind.\\

\emph{Erhebung von Qualit\"atsattributen -}
Da von den Eingaben die Qualit\"atsattribute besonders wichtig sind, ist es wichtig, dass sie angemessen erhoben wurden \cite{Cer01}. Im Rahmen von ADD 3.0 sind Qualit\"atsattribute als Szenarien zu formulieren. Szenarien bieten hier den Vorteil, dass mithilfe von diesen pr\"aziser formuliert werden kann, was genau ein Attribut aussagen soll und wie genau es messbar oder testbar sein kann. Die Erhebung solcher Szenarien kann beispielsweise mithilfe eines Qualit\"ats-Attribut-Workshops (QAW) realisiert werden, der den folgenden Aufbau hat \cite{Cer01}:\\

\begin{itemize}
\item[1.] QAW Pr\"asentation und Vorstellung
\item[2.] Gesch\"aftsziel Vorstellung
\item[3.] Architekturplan Vorstellung
\item[4.] Identifikation der architektonischen Treiber
\item[5.] Szenario Brainstorming
\item[6.] Szenario Konsolidierung
\item[7.] Szenario Priorisierung
\item[8.] Szenario Verfeinerung \\
\end{itemize}

Nachdem alle Eingaben gegeben sind, sind die sieben Schritte von ADD 3.0 auszuf\"uhren.\\

\emph{Schritt 1: Eingaben pr\"ufen -}
Zun\"achst muss sichergestellt werden, dass die \"ubergeordnete Zielstellung f\"ur die darauffolgenden Design-Aktivit\"aten festgelegt ist. Dies bedeutet zun\"achst muss der Design Grund validiert werden. Diese kann beispielsweise die erstmalige Erstellung eines Design-Entwurfes oder die Verbesserung eines vorhandenen Architektur-Designs sein. Danach wird \"uberpr\"uft, ob die f\"ur die Design-Round relevanten Anforderungen und Szenarien korrekt sind. Hier ist unter anderem zu pr\"ufen ob alle relevanten Stakeholder ber\"ucksichtigt werden und ob die erhobenen Anforderungen richtig priorisiert sind. Zuletzt muss noch gepr\"uft werden, ob es Einschr\"ankungen bez\"uglich der Software-Architektur gibt, die in der Design-Round zu ber\"ucksichtigen sind.\\

\emph{Schritt 2: Ziel der Iteration festlegen durch Wahl der Treiber -}
ADD 3.0 wird in der Regel in mehreren Iterationen ausgef\"uhrt wobei jede Design-Round ein Ziel verfolgt. Durch die Auswahl von Design Gr\"unden, Qualit\"atsattributen und prim\"aren Funktionalit\"aten wird festgelegt welche Ziele in einer Design-Round verfolgt werden \cite{Cer01}.\\

\emph{Schritt 3: W\"ahle mindestens ein Systemelement f\"ur eine Verfeinerung aus -}
Um die Treiber zu bedienen ist es notwendig mindestens eine architektonische Struktur zu konzipieren. Ansonsten ist es beispielsweise unm\"oglich die Qualit\"atsattribute vollst\"andig zu erf\"ullen. In der ersten Iteration k\"onnte eine solche Struktur beispielsweise das System als ganzes sein, welches in mehreren Iterationen in mehrere Teilsysteme aufgeteilt wird, die miteinander in Beziehung stehen oder voneinander abh\"angig sein k\"onnen \cite{Cer01}.\\

\emph{Schritt 4: W\"ahle mindestens ein Design Konzept, welches sich auf die Treiber anwenden l\"asst -}
Abh\"angig von den ausgew\"ahlten Treibern gibt es eine Vielzahl von Design Konzepten, die sich anwenden lassen. In diesem Schritt sind die Alternativen abzuw\"agen und die Kosten der Implementierung einzusch\"atzen um zu entscheiden, welche Design Konzepte anzuwenden sind. So gibt es beispielsweise viele gut dokumentierte Design Konzepte, die eine hohe Verf\"ugbarkeit erzielen und gleichzeitig den Single-Point-of-Failure vermeiden \cite{Cer01}.\\

\emph{Schritt 5: Instanziere Architekturelemente, weise Verantwortlichkeiten zu und definiere Schnittstellen -}
Nach der Auswahl der Design Konzepte kann es abh\"angig von der Auswahl notwendig sein, diese zu konfigurieren. Wird beispielsweise ein Schichten Pattern verwendet muss entschieden werden wie viele Schichten es geben soll. Neben der Instanzierung der Architekturelemente ist es notwendig diese zuzuordnen. Weiter ist es notwendig die instanzierten Architekturelemente miteinander zu verbinden um Kollaborationen zu erm\"oglichen \cite{Cer01}.\\

\emph{Schritt 6: Skizziere Sichten und dokumentiere Design Entscheidungen -}
Nachdem nun die Architekturentscheidung der Design Round getroffen sind ist es notwendig diese formalisiert festzuhalten und getroffene Design-Entscheidungen zu dokumentieren. Bei der Dokumentation m\"ussen die Architekturentscheidungen weiter verfeinert und \"uberpr\"uft werden \cite{Cer01}. \\

\emph{Schritt 7: Analyisiere das aktuelle Design und pr\"ufe ob das Ziel der Iteration erreicht ist -}
In diesem Schritt gilt es das aktuelle Design zu analysieren und zu \"uberpr\"ufen ob es Fehler oder Inkonsistenzen gibt. Ferner ist zu pr\"ufen ob das in den Treibern vorgegebene Ziel erreicht ist. Ist dies nicht der Fall, ist es notwendig zu iterieren und die Schritte ab Schritt zwei zu wiederholen. Im Gesamtprojekt kann das aktuelle Design als weitere Eingabe f\"ur eine weitere Design-Round angesehen werden. 

\paragraph{Ausgabe}
Nach der Ausf\"uhrung der sieben Schritte sollte ein verfeinerter Architekturentwurf erzeugt sein. Dieser kann in fr\"uhen Iterationen noch \"uber Inkonsistenzen verf\"ugen, daher gilt: Desto mehr Iterationen durchgef\"uhrt werden desto solider ist der Architekturentwurf. \\
