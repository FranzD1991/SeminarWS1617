\paragraph{Vergleich zwischen ADD 3.0 und Probing (FDD)}
Vergleicht man ADD 3.0 und Probing fällt vor allem auf, dass die Methoden an sehr unterschiedlichen Stellen eingesetzt werden. Probing wird eingesetzt um ASFR zu gewinnen und ADD 3.0 wird eingesetzt um auf der Basis von Anforderungen eine Software-Architektur zu erzeugen. Vergleicht man die Ziele fällt dies besonders auf. Bei der Betrachtung der Randbedingungen fällt auf, dass hier ebenfalls keine vergleichbare Schnittmenge gegeben ist. Jedoch fällt auf, dass eine der Randbedingungen von ADD 3.0 durch Probing gut zu erfüllen wäre. Das festhalten von Architekturrelevanten Anforderungen ist eine gute Grundlage für die Qualitätsattribute, die ADD 3.0 benötigt. Probing ließe sich als eine Alternative zu einem Qualitäts-Attribut-Workshop ansehen, die es ermöglicht mit womöglich geringeren Personalaufwand alle ASFR zu gewinnen. \\

\paragraph{Vergleich zwischen COSMOD-RE und ADD 3.0 (FDD)}
Im Vergleich von COSMOD-RE und ADD 3.0 gibt es eine Vielzahl von Auffälligkeiten. So haben sowohl ADD 3.0 als auch COSMOD-RE als ein Ziel den Entwurf einer Software-Architektur. Zusätzlich hat COSMOD-RE jedoch noch weitere Ziele, wie die Gewinnung von Anforderungen. Um COSMOD-RE anzuwenden müssen einige Randbedingungen geklärt werden, wie beispielsweise die Definition der Grenzen zwischen verschiedenen Ebenen der Abstraktionshierarchie oder eine Möglichkeit der Verknüpfung von Architektur- und Anforderungsmodellen. Außerdem muss eine System-Vision vorhanden sein. Ähnlich umfangreich sind die Randbedingungen von ADD 3.0. Hier wird vorausgesetzt, dass die Anforderungserhebung abgeschlossen ist und die Projekttreiber vorhanden sind. Besonders die Qualitätsattribute sollten vernünftig erhoben sein. Die ersten großen Unterschiede ergeben sich bei der Betrachtung der Eingaben. COSMOD-RE benötigt als Eingabe lediglich die System-Vision, während ADD 3.0 eine Menge von Projekttreibern benötigt. Die große Menge an ausführlichen Projekttreibern sind ein Nachteil an ADD 3.0, den COSMOD-RE nicht hat. Wenn es darum geht, einen schnellen Einstieg in die Methode zu erlangen, hat COSMOD-RE hier einen Vorteil. Ein Nachteil von COSMOD-RE offenbart sich jedoch, wenn die Ausgaben betrachtet werden. Während COSMOD-RE hier lediglich grobe Architekturartefakte liefert, kann ADD 3.0 eine verfeinerte Software-Architektur generieren. Dies bedeutet wenn der Mehraufwand zu beginn betrieben wird, ist es möglich eine bessere Ausgabe zu produzieren. \\

Besonders auffällig sind die Geschwindigkeiten in denen die Methoden arbeiten. COSMOD-RE hat vier Hierarchieebenen auf denen Anforderungen erhoben werden und die Software-Architektur erstellt wird. Dies wird über die drei CO-Design Prozesse geregelt, in denen jeweils zwei Hierarchieebenen untersucht werden. Jeder dieser drei CO-Design Prozesse führt die fünf Subprozesse aus, die wiederum vergleichbar mit einem Sprint bei SCRUM sind. Somit ist eine Mindestlaufzeit von drei SCRUM-Sprints gegeben, wobei hier nicht berücksichtigt ist, dass jeder der CO-Design Prozesse aufgrund der fünf Subprozesse länger als ein Sprint dauern kann. Bei ADD 3.0 ist ein Durchlauf vergleichbar mit einem Sprint bei SCRUM. Dies bedeutet, die verfeinerte Software-Architektur kann nach einem Sprint bereits fertig sein.\\

ADD 3.0 kann schnell Ergebnisse liefern. Dies ist jedoch hauptsächlich bei kleineren Projekten ein Vorteil. Bei größeren Projekten kann es passieren, dass man sehr unpräzise Ergebnisse erhält, wenn man bei ADD 3.0 nicht genügend Iterationen vollzieht. Hier hat COSMOD-RE den Vorteil, dass hier das Vorgehen durch die verschiedenen Hierarchieebenen und CO-Design Prozesse sehr strukturiert ist.\\

COSMOD-RE beginnt bei der Anforderungsgewinnung und arbeitet bis sowohl die Anforderungen als auch die Software-Architektur erstellt sind. In SP2 wird die Architektursicht erstellt. Es wird jedoch nicht konkret vorgegeben, wie die Architektursicht zu erstellen ist. Dies bedeutet, hier wäre die Freiheit gegeben ADD 3.0 einzusetzen. Dadurch würde COSMOD-RE um ADD 3.0 erweitert werden. Dies würde zudem Lösungsansätze für die zwei Probleme liefern, die COSMOD-RE nicht gelöst bekommt.\\

\paragraph{Vergleich zwischen Probing und  COSMOD-RE (FDD)}
COSMOD-RE hat als Ziele sowohl Anforderungen zu gewinnen als auch eine Software-Architektur zu erzeugen. Probing hat hingegen die Gewinnung von ASFR als Ziel. Probing soll es ermöglichen schnell alle ASFR zu finden um so eine korrekte Software-Architektur zu ermöglichen. Währenddessen werden bei COSMOD-RE ausgehend von der System-Vision sowohl Anforderungen als auch Architekturartefakte abgeleitet. Betrachtet man die fünf Subprozesse bei COSMOD-RE ließe sich Probing der Entwicklung der Systemnutzungs-Sicht (SP1) zuordnen. Dies bedeutet bei einer Kombination der Ansätze würde durch Probing die initiale Systemnutzung-Sicht gewonnen werden, die dann in weiteren Iterationen verfeinert würde. Eine Kombination der beiden Ansätze würde eine Lösung des Problems P6 für COSMOD-RE darstellen.\\
